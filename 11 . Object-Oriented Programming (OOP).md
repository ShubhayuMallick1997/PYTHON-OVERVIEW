# 11. **Object-Oriented Programming (OOP)**

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of **objects**, which can contain data and methods to operate on that data. OOP promotes the use of reusable, modular code and is fundamental in Python for creating well-organized, maintainable programs.

## **1. Key Concepts of OOP**

The core principles of OOP are:

* **Classes**: A class is a blueprint for creating objects. It defines a set of attributes and methods that are common to all objects of that type.

* **Objects**: An object is an instance of a class. It is created by calling the class, and it contains actual values for the attributes defined in the class.

* **Methods**: Methods are functions defined inside a class that describe the behaviors of an object.

* **Attributes**: Attributes are the variables that belong to an object or class. They store the state or data associated with the object.

* **Inheritance**: Inheritance allows a new class (child class) to inherit attributes and methods from an existing class (parent class).

* **Polymorphism**: Polymorphism allows objects of different classes to be treated as objects of a common parent class. It also allows the same method to have different behaviors depending on the object calling it.

* **Encapsulation**: Encapsulation is the practice of keeping fields (attributes) private and exposing only necessary methods to interact with them. This helps to protect the integrity of the data.

* **Abstraction**: Abstraction hides the complex implementation details and shows only the essential features of the object.

## **2. Defining Classes and Creating Objects**

To define a class in Python, you use the `class` keyword followed by the class name and a colon. Inside the class, you can define methods and attributes.

### **Example: Basic Class Definition**

```python
class Dog:
    # Class attribute
    species = "Canis familiaris"

    # Initializer / Constructor
    def __init__(self, name, age):
        # Instance attributes
        self.name = name
        self.age = age

    # Method
    def bark(self):
        print(f"{self.name} says woof!")

# Create an object (instance) of the class
dog1 = Dog("Buddy", 3)

# Accessing attributes and methods
print(dog1.name)  # Output: Buddy
print(dog1.age)   # Output: 3
dog1.bark()       # Output: Buddy says woof!
```

## **3. The `__init__` Method (Constructor)**

The `__init__` method is a special method that is automatically called when a new object of the class is created. It initializes the object's attributes.

### **Example**:

```python
class Car:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

# Creating an object
my_car = Car("Toyota", "Corolla", 2020)
```

## **4. Inheritance**

Inheritance allows a new class to inherit the properties and methods of an existing class, which promotes code reuse.

### **Example: Inheritance**

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound")

class Dog(Animal):
    def speak(self):
        print(f"{self.name} barks")

class Cat(Animal):
    def speak(self):
        print(f"{self.name} meows")

# Creating objects
dog = Dog("Buddy")
cat = Cat("Whiskers")

dog.speak()  # Output: Buddy barks
cat.speak()  # Output: Whiskers meows
```

In this example, `Dog` and `Cat` inherit from the `Animal` class, but each class has its own implementation of the `speak()` method.

## **5. Polymorphism**

Polymorphism allows methods to have different behaviors depending on the object. In Python, this is typically achieved through method overriding (where a child class provides its own version of a method defined in the parent class).

### **Example: Polymorphism**

```python
class Bird(Animal):
    def speak(self):
        print(f"{self.name} chirps")

animals = [Dog("Rex"), Cat("Fluffy"), Bird("Tweety")]

for animal in animals:
    animal.speak()
```

Output:

```
Rex barks
Fluffy meows
Tweety chirps
```

In this case, the `speak()` method behaves differently depending on the object (`Dog`, `Cat`, `Bird`) calling it.

## **6. Encapsulation**

Encapsulation involves restricting direct access to certain attributes and methods of an object, while still providing controlled access through public methods.

* **Private Attributes**: In Python, private attributes are not strictly enforced, but they can be indicated by a leading underscore (`_`) or double underscore (`__`) in the attribute name.

* **Getters and Setters**: Methods that get or set the value of private attributes are called getters and setters.

### **Example: Encapsulation with Getter and Setter**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age  # Private attribute

    # Getter method for age
    def get_age(self):
        return self.__age

    # Setter method for age
    def set_age(self, age):
        if age >= 0:
            self.__age = age
        else:
            print("Age cannot be negative")

# Creating an object
person = Person("Alice", 30)

# Accessing private attribute using getter and setter
print(person.get_age())  # Output: 30
person.set_age(35)
print(person.get_age())  # Output: 35
person.set_age(-5)       # Output: Age cannot be negative
```

## **7. Abstraction**

Abstraction allows you to hide the complex implementation details and expose only the essential features of the object. In Python, abstraction can be achieved using abstract base classes (ABC) and abstract methods.

* **Abstract Classes**: Abstract classes cannot be instantiated directly. They are meant to be subclassed, and their abstract methods must be implemented by subclasses.

### **Example: Abstraction with ABC**

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        print("Bark")

# Creating an object of Dog class
dog = Dog()
dog.sound()  # Output: Bark
```

In this example, the `Animal` class is abstract, and the `sound` method must be implemented by any subclass (like `Dog`).

---

### **Why Learn OOP in Python?**

* **Modularity**: Classes allow you to create modular, reusable code, which is easier to maintain and extend.
* **Code Reusability**: Inheritance enables you to reuse code from existing classes, making development faster and reducing redundancy.
* **Organization**: OOP helps you organize your code in a logical, hierarchical structure that models real-world entities more naturally.
* **Maintainability**: By using encapsulation and abstraction, you can hide implementation details and make your code more flexible and easier to maintain.

Mastering OOP is crucial for building scalable and maintainable applications. Understanding the concepts of classes, inheritance, polymorphism, encapsulation, and abstraction will help you write Python code that is both efficient and easy to understand.
