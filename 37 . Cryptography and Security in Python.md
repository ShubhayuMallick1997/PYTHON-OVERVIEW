# 37 . **Cryptography and Security in Python**

Cryptography is the practice of securing communication and data through various techniques, such as encryption, decryption, and hashing. Python provides several libraries for implementing cryptographic functions, and here we'll focus on two important aspects: **hashing** and **encryption/decryption**.

---

## **1. Hashing in Python (Using `hashlib`)**

**Hashing** is the process of converting input data (e.g., a string or file) into a fixed-size string of characters, which is typically a hash value. Hashing is often used for password storage, data integrity verification, and digital signatures. Common hashing algorithms include **SHA-256**, **MD5**, and **SHA-1**.

### **Using the `hashlib` Library**

Python's `hashlib` module provides various algorithms for hashing data.

1. **Install hashlib (it comes pre-installed with Python)**:

```python
import hashlib
```

2. **Basic Hashing Example**:

```python
import hashlib

# Create a hash object using SHA-256
hash_object = hashlib.sha256()

# Update the hash object with data
data = "Hello, World!"
hash_object.update(data.encode('utf-8'))

# Get the hexadecimal representation of the hash
hex_hash = hash_object.hexdigest()
print(f"SHA-256 Hash: {hex_hash}")
```

### **Explanation**:

* **`hashlib.sha256()`**: Creates a SHA-256 hash object.
* **`update()`**: Adds data to the hash object (must be encoded as bytes).
* **`hexdigest()`**: Returns the hexadecimal representation of the hash.

3. **Hashing Passwords**:
   Hashing is often used for storing passwords securely. **Never store plain-text passwords**.

```python
password = "my_secure_password"
hashed_password = hashlib.sha256(password.encode('utf-8')).hexdigest()
print(f"Hashed Password: {hashed_password}")
```

### **Important Hashing Algorithms Available in `hashlib`**:

* **SHA-256**: Secure Hash Algorithm (SHA) with a 256-bit output.
* **MD5**: A commonly used hashing algorithm (although not recommended for cryptographic purposes due to vulnerabilities).
* **SHA-1**: Another SHA algorithm (also not recommended for security-sensitive applications due to vulnerabilities).

---

## **2. Encryption and Decryption in Python (Using `cryptography`)**

**Encryption** is the process of converting plaintext into a scrambled (ciphertext) format using a key. **Decryption** reverses this process, turning ciphertext back into plaintext. Python's `cryptography` library is a powerful tool for implementing secure encryption and decryption mechanisms.

### **Install the `cryptography` Library**

```bash
pip install cryptography
```

### **Symmetric Encryption (AES)**

In symmetric encryption, the same key is used for both encryption and decryption. **AES (Advanced Encryption Standard)** is a widely used symmetric encryption algorithm.

1. **Basic Symmetric Encryption with AES**:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

# Generate a random 256-bit key (32 bytes) for AES
key = os.urandom(32)

# Generate a random 128-bit IV (16 bytes)
iv = os.urandom(16)

# Encrypting data
def encrypt_data(data, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    padded_data = data + b'\0' * (16 - len(data) % 16)  # Pad the data to make it a multiple of 16
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return ciphertext

# Decrypting data
def decrypt_data(ciphertext, key, iv):
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()
    return decrypted_data.rstrip(b'\0')  # Remove padding

# Encrypt the data
data = b"Secret data"
ciphertext = encrypt_data(data, key, iv)
print(f"Ciphertext: {ciphertext}")

# Decrypt the data
decrypted_data = decrypt_data(ciphertext, key, iv)
print(f"Decrypted data: {decrypted_data.decode()}")
```

### **Explanation**:

* **`os.urandom()`**: Generates cryptographically secure random values for the encryption key and initialization vector (IV).
* **AES encryption**: Uses the AES algorithm in CBC (Cipher Block Chaining) mode.
* **Padding**: Data is padded to ensure its length is a multiple of the block size (16 bytes in this case).
* **Encryption and Decryption**: The `encryptor.update()` and `decryptor.update()` methods handle the data encryption and decryption.

### **Asymmetric Encryption (RSA)**

In **asymmetric encryption**, two keys are used: one public key for encryption and a private key for decryption. This is commonly used for secure communication and digital signatures.

1. **RSA Key Pair Generation and Encryption**:

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding

# Generate an RSA private and public key pair
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# Encrypt data using the public key
def encrypt_rsa(data, public_key):
    ciphertext = public_key.encrypt(
        data.encode('utf-8'),
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return ciphertext

# Decrypt data using the private key
def decrypt_rsa(ciphertext, private_key):
    plaintext = private_key.decrypt(
        ciphertext,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return plaintext.decode('utf-8')

# Encrypt the data
data = "Sensitive Information"
ciphertext = encrypt_rsa(data, public_key)
print(f"Encrypted RSA Data: {ciphertext}")

# Decrypt the data
decrypted_data = decrypt_rsa(ciphertext, private_key)
print(f"Decrypted RSA Data: {decrypted_data}")
```

### **Explanation**:

* **RSA key pair**: A private and a public key are generated using `rsa.generate_private_key()`.
* **OAEP Padding**: **Optimal Asymmetric Encryption Padding (OAEP)** is used to securely encrypt data.
* **Encryption and Decryption**: The `encrypt()` and `decrypt()` methods are used to encrypt and decrypt data.

---

## **3. Key Takeaways**

### **Hashing**:

* Hashing is used for data integrity and secure password storage. Common algorithms like **SHA-256** provide a fixed-size hash output that uniquely identifies data.
* **MD5** and **SHA-1** are considered broken and should not be used for cryptographic security purposes.

### **Symmetric Encryption**:

* **AES** is a common symmetric encryption algorithm that uses the same key for both encryption and decryption.
* **CBC (Cipher Block Chaining)** is a mode of operation that improves the security of AES encryption by introducing an initialization vector (IV).

### **Asymmetric Encryption**:

* **RSA** is an asymmetric encryption algorithm that uses two keys: a public key to encrypt and a private key to decrypt.
* Asymmetric encryption is typically used for secure communication, digital signatures, and key exchange protocols.

### **Security Best Practices**:

* **Key management**: Always ensure your encryption keys are securely managed. Use a secure key management system or service.
* **Avoid hardcoding sensitive information**: Never hardcode passwords or keys in your source code.
* **Use secure padding**: When using RSA or AES, always use secure padding schemes like **OAEP** (for RSA) and **PKCS7** (for AES).

---

## **Conclusion**

* **Hashing** is useful for securely storing passwords and ensuring data integrity.
* **Encryption** and **decryption** provide the foundation for secure communication and data protection.
* Libraries like **`hashlib`** and **`cryptography`** in Python make it easy to implement strong encryption and hashing schemes, while ensuring you follow best security practices.

Mastering these cryptographic techniques will help you build secure applications, protect sensitive data, and understand the core principles of security in software development.
