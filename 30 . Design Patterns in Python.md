# 30 . **Design Patterns in Python**

Design patterns are proven solutions to common software design problems. They provide a template or blueprint for solving problems that recur in software design. In Python, understanding and implementing design patterns can help create more flexible, maintainable, and scalable code.

Here, we'll cover a few key design patterns and **SOLID principles**, which are foundational principles in object-oriented design.

---

## **1. Singleton Design Pattern**

The **Singleton** pattern ensures that a class has only one instance and provides a global point of access to that instance. This is useful for situations like database connections, logging, and configuration settings.

### **Implementing Singleton in Python**

```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance

# Testing Singleton
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # Output: True (Both are the same instance)
```

### **Explanation:**

* The `__new__` method ensures that only one instance of the class is created.
* `cls._instance` stores the instance, and if it's `None`, it creates a new one. If it's already created, it returns the same instance.

---

## **2. Factory Design Pattern**

The **Factory** pattern provides an interface for creating objects, but the actual instantiation is deferred to subclasses. It helps to create objects without exposing the instantiation logic to the client and allows for more flexibility in choosing which class to instantiate.

### **Implementing Factory Pattern in Python**

```python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class AnimalFactory:
    def get_animal(self, animal_type):
        if animal_type.lower() == "dog":
            return Dog()
        elif animal_type.lower() == "cat":
            return Cat()
        else:
            return None

# Testing Factory Pattern
factory = AnimalFactory()
animal = factory.get_animal("dog")
print(animal.speak())  # Output: Woof!
```

### **Explanation:**

* The `AnimalFactory` class has a method `get_animal()` that returns an instance of a specific animal class (either `Dog` or `Cat`).
* This allows the client to create animals without directly calling the constructor of `Dog` or `Cat`.

---

## **3. Observer Design Pattern**

The **Observer** pattern is used when one object (the **subject**) needs to notify other objects (the **observers**) of a change in its state. This is often used in event handling systems, where changes in one part of the system trigger updates elsewhere.

### **Implementing Observer Pattern in Python**

```python
class Subject:
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self)

class Observer:
    def update(self, subject):
        raise NotImplementedError("Subclass must implement abstract method")

class ConcreteObserver(Observer):
    def update(self, subject):
        print("State updated in observer")

# Testing Observer Pattern
subject = Subject()
observer = ConcreteObserver()

subject.attach(observer)
subject.notify()  # Output: State updated in observer
```

### **Explanation:**

* The `Subject` class maintains a list of observers and provides methods to attach, detach, and notify observers.
* The `Observer` class defines the `update()` method that must be implemented by any concrete observer.
* When the state of the `Subject` changes, the `notify()` method is called to update all observers.

---

## **4. Strategy Design Pattern**

The **Strategy** pattern allows you to define a family of algorithms, encapsulate each one, and make them interchangeable. It enables selecting an algorithm at runtime based on user input or other factors.

### **Implementing Strategy Pattern in Python**

```python
class Strategy:
    def execute(self, a, b):
        raise NotImplementedError("Subclasses must implement this method")

class AddStrategy(Strategy):
    def execute(self, a, b):
        return a + b

class SubtractStrategy(Strategy):
    def execute(self, a, b):
        return a - b

class Context:
    def __init__(self, strategy: Strategy):
        self._strategy = strategy

    def set_strategy(self, strategy: Strategy):
        self._strategy = strategy

    def execute_strategy(self, a, b):
        return self._strategy.execute(a, b)

# Testing Strategy Pattern
context = Context(AddStrategy())
print(context.execute_strategy(5, 3))  # Output: 8

context.set_strategy(SubtractStrategy())
print(context.execute_strategy(5, 3))  # Output: 2
```

### **Explanation:**

* The `Strategy` class defines an abstract `execute()` method.
* `AddStrategy` and `SubtractStrategy` are concrete implementations of the `Strategy` class.
* The `Context` class is used to set and change strategies dynamically, executing the selected strategy at runtime.

---

## **5. SOLID Principles in Python**

The **SOLID** principles are five design principles that help software developers create more maintainable, scalable, and flexible software. They are particularly useful in object-oriented programming.

### **S - Single Responsibility Principle (SRP)**

A class should have only one reason to change, meaning it should only have one job or responsibility.

```python
# Violates SRP
class UserManager:
    def create_user(self):
        pass  # User creation logic

    def send_email(self):
        pass  # Email sending logic

# Follows SRP
class UserCreator:
    def create_user(self):
        pass  # User creation logic

class EmailSender:
    def send_email(self):
        pass  # Email sending logic
```

### **O - Open/Closed Principle (OCP)**

Software entities should be open for extension but closed for modification. You can add new functionality without changing existing code.

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def area(self):
        return self.width * self.height

# New shape added without modifying the original classes
class Circle(Shape):
    def area(self):
        return 3.14 * self.radius ** 2
```

### **L - Liskov Substitution Principle (LSP)**

Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.

```python
class Bird:
    def fly(self):
        print("Flying")

class Penguin(Bird):
    def fly(self):
        pass  # Penguins cannot fly (violates LSP)

# Correct approach:
class Bird:
    def move(self):
        pass

class Sparrow(Bird):
    def move(self):
        print("Flying")

class Penguin(Bird):
    def move(self):
        print("Swimming")
```

### **I - Interface Segregation Principle (ISP)**

Clients should not be forced to implement interfaces they do not use. This encourages the use of smaller, more specific interfaces.

```python
# Violates ISP
class MultiFunctionPrinter:
    def print(self):
        pass

    def scan(self):
        pass

    def fax(self):
        pass

# Follows ISP
class Printer:
    def print(self):
        pass

class Scanner:
    def scan(self):
        pass

class FaxMachine:
    def fax(self):
        pass
```

### **D - Dependency Inversion Principle (DIP)**

High-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore, abstractions should not depend on details; details should depend on abstractions.

```python
# Violates DIP
class FileManager:
    def __init__(self, file):
        self.file = file  # Direct dependency on File

    def save(self):
        pass

# Follows DIP
class Storage:
    def save(self):
        pass

class FileManager:
    def __init__(self, storage: Storage):
        self.storage = storage  # Dependency injection

    def save(self):
        self.storage.save()
```

---

## **Why Learn Design Patterns and SOLID Principles?**

* **Maintainability**: Design patterns help you structure code in a way that makes it easier to maintain and extend over time.
* **Scalability**: Following principles like SOLID ensures that your code is flexible and can grow with the application.
* **Code Reusability**: Design patterns encourage reusability, reducing the need to rewrite code.
* **Readability**: Using established patterns makes your code more understandable for others, improving collaboration in teams.

By mastering design patterns and the **SOLID** principles, you'll be able to write more efficient, scalable, and maintainable code, which is a key skill in software development.
