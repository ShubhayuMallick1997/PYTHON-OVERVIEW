# 24 . **Advanced Functions in Python**

Python allows you to write functions that are not just tools for code organization but also powerful components for enhancing program flexibility, code reusability, and solving complex problems. In this topic, we cover **decorators**, **closures**, **higher-order functions**, and **recursion** — all advanced function techniques that enhance Python programming.

---

## **1. Decorators**

A **decorator** is a function that modifies or extends the behavior of another function. They are used to add functionality to an existing function without modifying its structure. Decorators are widely used for logging, access control, memoization, and more.

### **Basic Syntax of Decorators**

A decorator is a function that returns another function. The inner function "wraps" the original function.

```python
def decorator_function(original_function):
    def wrapper_function():
        print(f"Wrapper executed before {original_function.__name__}")
        return original_function()
    return wrapper_function

# Applying decorator using @
@decorator_function
def display():
    print("Display function executed")

display()
```

Output:

```
Wrapper executed before display
Display function executed
```

### **Practical Example: Logging Decorator**

A decorator can be used to log function calls.

```python
def log_decorator(func):
    def wrapper():
        print(f"Function {func.__name__} is being called.")
        return func()
    return wrapper

@log_decorator
def say_hello():
    print("Hello, World!")

say_hello()
```

Output:

```
Function say_hello is being called.
Hello, World!
```

### **Chaining Decorators**

Multiple decorators can be applied to a function, which are executed from bottom to top.

```python
def decorator_one(func):
    def wrapper():
        print("Decorator One applied")
        return func()
    return wrapper

def decorator_two(func):
    def wrapper():
        print("Decorator Two applied")
        return func()
    return wrapper

@decorator_one
@decorator_two
def greet():
    print("Hello!")

greet()
```

Output:

```
Decorator One applied
Decorator Two applied
Hello!
```

---

## **2. Closures**

A **closure** is a function that remembers the environment in which it was created. This means a closure can access variables from its enclosing scope even after that scope has finished executing.

### **Example: Basic Closure**

```python
def outer_function(outer_variable):
    def inner_function(inner_variable):
        return outer_variable + inner_variable
    return inner_function

# Create a closure
closure = outer_function(10)
print(closure(5))  # Output: 15
```

### **Explanation:**

* The `inner_function` has access to the variable `outer_variable`, even after the `outer_function` has finished executing.
* This allows for maintaining state across function calls.

## **Practical Example: Function Factory**

Closures can be used to create functions that remember certain parameters:

```python
def make_multiplier(factor):
    def multiplier(number):
        return number * factor
    return multiplier

# Create two different multiplier functions
double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # Output: 10
print(triple(5))  # Output: 15
```

---

## **3. Higher-Order Functions**

A **higher-order function** is a function that either:

1. Takes one or more functions as arguments, or
2. Returns a function as a result.

Python's built-in functions like `map()`, `filter()`, and `reduce()` are examples of higher-order functions.

### **`map()` Function**

The `map()` function applies a given function to all items in an iterable and returns a map object (which is an iterator).

```python
numbers = [1, 2, 3, 4, 5]
squared_numbers = map(lambda x: x ** 2, numbers)

print(list(squared_numbers))  # Output: [1, 4, 9, 16, 25]
```

### **`filter()` Function**

The `filter()` function filters elements from an iterable based on a given condition (provided by a function). It returns an iterator that produces items for which the function returns `True`.

```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)

print(list(even_numbers))  # Output: [2, 4, 6]
```

### **`reduce()` Function**

The `reduce()` function from the `functools` module applies a binary function cumulatively to the items in an iterable and returns a single result.

```python
from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)

print(product)  # Output: 24
```

### **Other Examples of Higher-Order Functions:**

* **`sorted()`**: Sorts an iterable, optionally using a custom comparison function.
* **`all()`**: Returns `True` if all elements of the iterable are true.
* **`any()`**: Returns `True` if any element of the iterable is true.

---

## **4. Recursion**

**Recursion** is a technique where a function calls itself to solve smaller instances of a problem. Recursive functions are often simpler and more elegant than iterative solutions, especially for problems with a recursive structure (e.g., tree traversal).

### **Basic Recursion Example**

```python
def factorial(n):
    if n == 0:  # Base case
        return 1
    return n * factorial(n - 1)

print(factorial(5))  # Output: 120
```

### **Explanation:**

* The function `factorial` calls itself with a smaller value of `n` until it reaches the base case (`n == 0`).
* This is a classic example of recursion where the problem is broken down into smaller subproblems.

### **Recursion with Multiple Parameters**

Recursion can also be applied with multiple parameters. For example, calculating Fibonacci numbers:

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(6))  # Output: 8
```

### **Tail Recursion**

In **tail recursion**, the recursive call is the last action performed in the function. Python does not optimize tail recursion, but it’s a concept used in other programming languages.

```python
def factorial_tail_recursive(n, accumulator=1):
    if n == 0:
        return accumulator
    return factorial_tail_recursive(n - 1, n * accumulator)

print(factorial_tail_recursive(5))  # Output: 120
```

### **Why Use Recursion?**

* **Natural for recursive problems**: Recursion is ideal for problems that can be broken down into similar subproblems, such as tree traversal, factorial calculation, and searching/sorting algorithms.
* **Simpler code**: Recursive solutions can be cleaner and easier to understand compared to their iterative counterparts.

---

### **Why Learn Advanced Functions in Python?**

* **Functional Programming**: Decorators, closures, and higher-order functions allow you to use a more functional programming style, where functions are treated as first-class citizens.
* **Code Modularity**: Decorators and closures allow you to modify or extend function behavior without changing the core function itself.
* **Efficiency**: Recursion allows for elegant solutions to complex problems, while higher-order functions like `map()`, `filter()`, and `reduce()` provide efficient alternatives to loops.
* **Problem Solving**: These advanced functions enable you to solve problems in a more modular and flexible way, leading to cleaner, reusable code.

Mastering these concepts will greatly enhance your Python programming skills, enabling you to write more efficient, readable, and maintainable code.
