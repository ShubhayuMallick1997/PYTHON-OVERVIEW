# 19. **Data Structures: Stacks, Queues, and Linked Lists**

Understanding and implementing common data structures like **stacks**, **queues**, and **linked lists** is fundamental to becoming proficient in programming. These structures are key for managing data efficiently in algorithms and applications, such as managing tasks, reversing elements, and storing sequences.

## **1. Stacks**

A **stack** is a linear data structure that follows the **LIFO** (Last In, First Out) principle. This means the last element added to the stack is the first one to be removed.

### **Operations in a Stack**

* **Push**: Adds an element to the top of the stack.
* **Pop**: Removes the element from the top of the stack.
* **Peek**: Returns the element at the top without removing it.
* **isEmpty**: Checks whether the stack is empty.

### **Example: Implementing a Stack in Python**

```python
class Stack:
    def __init__(self):
        self.stack = []
    
    def push(self, item):
        self.stack.append(item)  # Adds an item to the stack
    
    def pop(self):
        if not self.isEmpty():
            return self.stack.pop()  # Removes and returns the top item
        return "Stack is empty"
    
    def peek(self):
        if not self.isEmpty():
            return self.stack[-1]  # Returns the top item without removing it
        return "Stack is empty"
    
    def isEmpty(self):
        return len(self.stack) == 0  # Checks if the stack is empty

# Using the Stack
stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)

print(stack.peek())  # Output: 30
print(stack.pop())   # Output: 30
print(stack.peek())  # Output: 20
```

### **Applications of Stacks:**

* Undo functionality in text editors.
* Expression evaluation (e.g., balancing parentheses).
* Depth-first search (DFS) in graphs.

## **2. Queues**

A **queue** is a linear data structure that follows the **FIFO** (First In, First Out) principle. This means the first element added to the queue is the first one to be removed.

### **Operations in a Queue**

* **Enqueue**: Adds an element to the rear of the queue.
* **Dequeue**: Removes the element from the front of the queue.
* **Front**: Returns the element at the front without removing it.
* **isEmpty**: Checks whether the queue is empty.

### **Example: Implementing a Queue in Python**

```python
class Queue:
    def __init__(self):
        self.queue = []
    
    def enqueue(self, item):
        self.queue.append(item)  # Adds an item to the queue
    
    def dequeue(self):
        if not self.isEmpty():
            return self.queue.pop(0)  # Removes and returns the front item
        return "Queue is empty"
    
    def front(self):
        if not self.isEmpty():
            return self.queue[0]  # Returns the front item without removing it
        return "Queue is empty"
    
    def isEmpty(self):
        return len(self.queue) == 0  # Checks if the queue is empty

# Using the Queue
queue = Queue()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)

print(queue.front())  # Output: 10
print(queue.dequeue())  # Output: 10
print(queue.front())  # Output: 20
```

### **Applications of Queues:**

* Managing tasks in print queues or task scheduling systems.
* Breadth-first search (BFS) in graphs.
* Simulating waiting lines in applications (e.g., online checkout systems).

## **3. Linked Lists**

A **linked list** is a linear data structure where each element (called a node) contains two parts:

* **Data**: The value or information stored in the node.
* **Next**: A reference (or pointer) to the next node in the list.

Unlike arrays or lists, linked lists are not stored in contiguous memory locations, which allows efficient insertion and deletion.

### **Types of Linked Lists**

* **Singly Linked List**: Each node points to the next node in the list.
* **Doubly Linked List**: Each node points to both the next and previous nodes.
* **Circular Linked List**: The last node points to the first node, making the list circular.

### **Operations in a Linked List**

* **Insert**: Adds a new node to the list.
* **Delete**: Removes a node from the list.
* **Search**: Finds an element in the list.
* **Traverse**: Iterates through the list to visit each node.

### **Example: Implementing a Singly Linked List**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None  # Points to the next node

class LinkedList:
    def __init__(self):
        self.head = None
    
    def insert(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node  # Insert at the beginning
    
    def delete(self, data):
        current = self.head
        if current is None:
            print("List is empty")
            return
        if current.data == data:
            self.head = current.next  # Remove the head node
            return
        while current.next:
            if current.next.data == data:
                current.next = current.next.next  # Remove the node
                return
            current = current.next
    
    def traverse(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Using the Linked List
ll = LinkedList()
ll.insert(10)
ll.insert(20)
ll.insert(30)
ll.traverse()  # Output: 30 -> 20 -> 10 -> None

ll.delete(20)
ll.traverse()  # Output: 30 -> 10 -> None
```

### **Applications of Linked Lists:**

* Dynamic memory allocation.
* Implementing queues, stacks, and other abstract data types.
* Representing graphs and sparse matrices.

## **4. Doubly Linked Lists**

In a **doubly linked list**, each node contains two pointers: one pointing to the next node and another pointing to the previous node. This structure allows traversal in both directions.

### **Example: Implementing a Doubly Linked List**

```python
class DoublyNode:
    def __init__(self, data):
        self.data = data
        self.next = None  # Points to the next node
        self.prev = None  # Points to the previous node

class DoublyLinkedList:
    def __init__(self):
        self.head = None
    
    def insert(self, data):
        new_node = DoublyNode(data)
        new_node.next = self.head
        if self.head:
            self.head.prev = new_node
        self.head = new_node
    
    def delete(self, data):
        current = self.head
        if current is None:
            print("List is empty")
            return
        if current.data == data:
            self.head = current.next
            if self.head:
                self.head.prev = None
            return
        while current:
            if current.data == data:
                current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                return
            current = current.next
    
    def traverse(self):
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

# Using the Doubly Linked List
dll = DoublyLinkedList()
dll.insert(10)
dll.insert(20)
dll.insert(30)
dll.traverse()  # Output: 30 <-> 20 <-> 10 <-> None

dll.delete(20)
dll.traverse()  # Output: 30 <-> 10 <-> None
```

## **5. Circular Linked Lists**

In a **circular linked list**, the last nodeâ€™s `next` pointer points back to the first node, forming a loop. This is useful in applications that require continuous traversal of the list.

---

### **Why Use Stacks, Queues, and Linked Lists?**

* **Efficient Memory Use**: Linked lists are ideal for applications where the size of the data structure is unknown or changes frequently, as they do not require contiguous memory allocation.
* **Optimized Operations**: Stacks and queues allow efficient operations (push/pop and enqueue/dequeue) that can be used in real-time systems and task scheduling.
* **Implementing Complex Data Structures**: These fundamental data structures form the building blocks of more complex structures like graphs, trees, and databases.

Mastering these data structures helps solve problems in various fields, including algorithms, system design, and data storage, while also improving the efficiency of your applications.
