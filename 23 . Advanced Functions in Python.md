# 23 . **Advanced Functions in Python**

In Python, functions are first-class objects, which means they can be passed as arguments, returned from other functions, and assigned to variables. This allows for more advanced programming techniques, such as **decorators**, **closures**, **higher-order functions**, and **recursion**. These concepts provide powerful tools for more expressive, modular, and functional code.

---

### **1. Decorators**

A **decorator** is a function that modifies the behavior of another function or method. Decorators are commonly used for logging, enforcing access control, instrumentation, and caching.

## **Basic Syntax of Decorators**

Decorators are typically defined using the `@decorator_name` syntax, which is applied to a function or method to enhance its behavior.

```python
def decorator_function(original_function):
    def wrapper_function():
        print("Wrapper executed this before {}".format(original_function.__name__))
        return original_function()
    return wrapper_function

# Applying decorator using @
@decorator_function
def display():
    print("Display function executed")

display()
```

## **Explanation:**

* **`decorator_function`** is the decorator that wraps the `display()` function.
* The **`wrapper_function`** adds extra behavior before calling the original function (`display()`).

Output:

```
Wrapper executed this before display
Display function executed
```

## **Real-life Use of Decorators:**

Decorators are widely used for tasks such as **logging**, **authentication**, **performance monitoring**, etc.

```python
def log_decorator(func):
    def wrapper():
        print(f"Logging: {func.__name__} is called.")
        return func()
    return wrapper

@log_decorator
def say_hello():
    print("Hello World!")

say_hello()
```

Output:

```
Logging: say_hello is called.
Hello World!
```

## **Chaining Decorators**

Multiple decorators can be applied to a single function, and they are executed in the order they are applied (from bottom to top).

```python
def decorator_one(func):
    def wrapper():
        print("Decorator One applied")
        return func()
    return wrapper

def decorator_two(func):
    def wrapper():
        print("Decorator Two applied")
        return func()
    return wrapper

@decorator_one
@decorator_two
def greet():
    print("Hello!")

greet()
```

Output:

```
Decorator One applied
Decorator Two applied
Hello!
```

---

### **2. Closures**

A **closure** occurs when a nested function remembers and has access to variables in the local scope in which it was created, even after the outer function has finished executing.

## **Creating a Closure**

```python
def outer_function(outer_variable):
    def inner_function(inner_variable):
        return outer_variable + inner_variable
    return inner_function

# Create a closure
closure = outer_function(10)
print(closure(5))  # Output: 15
```

## **Explanation:**

* **`outer_function`** returns `inner_function`, which has access to `outer_variable` from its enclosing scope.
* Even after `outer_function` has completed, `inner_function` retains access to `outer_variable`.

## **Use Cases of Closures:**

Closures are commonly used in scenarios where you need to maintain state across function calls (like function factories) or implement decorators.

---

### **3. Higher-Order Functions**

A **higher-order function** is a function that can take another function as an argument or return a function as a result. Common higher-order functions in Python include `map()`, `filter()`, and `reduce()`.

## **`map()` Function**

The `map()` function applies a given function to each item of an iterable (list, tuple, etc.) and returns an iterator of the results.

```python
# Example: Using map to square each element in a list
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # Output: [1, 4, 9, 16, 25]
```

## **`filter()` Function**

The `filter()` function filters elements from an iterable based on a given function that returns either `True` or `False`.

```python
# Example: Using filter to select even numbers
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # Output: [2, 4, 6]
```

## **`reduce()` Function**

The `reduce()` function from the `functools` module is used to apply a binary function (a function that takes two arguments) cumulatively to the items of an iterable.

```python
from functools import reduce

# Example: Using reduce to multiply all elements in a list
numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 24
```

In this example, `reduce()` computes the cumulative product of the numbers in the list.

## **Summary of Higher-Order Functions:**

* **`map()`** applies a function to every item in an iterable.
* **`filter()`** filters the elements of an iterable based on a condition.
* **`reduce()`** applies a function cumulatively to the items of an iterable and returns a single result.

---

### **4. Recursion**

**Recursion** is a technique where a function calls itself in order to solve a problem. Recursive algorithms are often used for tasks that can be broken down into smaller subproblems, such as factorial calculations, tree traversal, and searching.

## **Basic Recursion Example**

```python
def factorial(n):
    if n == 0:  # Base case: factorial of 0 is 1
        return 1
    return n * factorial(n - 1)

print(factorial(5))  # Output: 120
```

## **Explanation:**

* The function calls itself with a smaller value of `n` until it reaches the base case (`n == 0`).
* The recursive calls "unwind" when the base case is reached, and the final result is calculated.

## **Tail Recursion**

In **tail recursion**, the recursive call is the last operation in the function. Python does not optimize tail recursion, but many functional languages do. However, it's still a good concept to understand.

```python
def factorial_tail_recursive(n, accumulator=1):
    if n == 0:
        return accumulator
    return factorial_tail_recursive(n - 1, n * accumulator)

print(factorial_tail_recursive(5))  # Output: 120
```

In this version, the function maintains an accumulator to carry the result as it recursively calls itself.

## **Use Cases for Recursion:**

* **Factorial calculation**
* **Tree traversal**
* **Searching and sorting algorithms (e.g., quicksort, mergesort)**
* **Solving puzzles (e.g., the Tower of Hanoi)**

---

### **Why Learn Advanced Functions in Python?**

* **Functional Programming**: Advanced functions like decorators, closures, and higher-order functions enable a more functional programming style in Python, which can lead to cleaner, more maintainable code.
* **Flexibility**: Decorators and higher-order functions allow you to write more reusable, modular, and flexible code.
* **Problem Solving**: Recursion is a powerful problem-solving technique, especially for problems that have a recursive structure, such as tree and graph traversal.
* **Efficiency**: Understanding recursion and higher-order functions like `map()`, `filter()`, and `reduce()` allows you to solve problems in a more efficient and elegant way.

By mastering these advanced function concepts, you'll be able to write more sophisticated and efficient Python code, improving both your problem-solving skills and your ability to write high-quality, reusable software.
