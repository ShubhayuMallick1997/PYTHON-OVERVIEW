# 6. **Error Handling**

Error handling is crucial in programming to ensure that your code runs smoothly even when unexpected situations occur. In Python, error handling is achieved using **try**, **except**, **else**, and **finally** blocks. These allow you to manage and respond to errors gracefully instead of letting the program crash.

## **1. The `try` and `except` Blocks**

The `try` block is used to wrap the code that may potentially raise an exception. If an exception occurs, the program will stop executing the code inside the `try` block and jump to the `except` block. The `except` block is used to handle the error.

Example:

```python
try:
    result = 10 / 0  # This will cause a division by zero error
except ZeroDivisionError as e:
    print(f"Error: {e}")
```

Output:

```
Error: division by zero
```

In the above example, the `ZeroDivisionError` is caught, and an appropriate message is printed.

## **2. Catching Multiple Exceptions**

You can handle multiple types of exceptions by using multiple `except` blocks.

Example:

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ZeroDivisionError:
    print("You cannot divide by zero!")
except ValueError:
    print("That's not a valid number!")
```

Output (if the user enters a non-numeric value):

```
That's not a valid number!
```

## **3. The `else` Block**

The `else` block is optional and runs if no exceptions are raised in the `try` block. It is useful for code that should only run if no error occurred.

Example:

```python
try:
    number = int(input("Enter a number: "))
    result = 10 / number
except ZeroDivisionError:
    print("You cannot divide by zero!")
except ValueError:
    print("That's not a valid number!")
else:
    print(f"The result is {result}")
```

Output (if the user enters `2`):

```
The result is 5.0
```

## **4. The `finally` Block**

The `finally` block is used for code that should always run, regardless of whether an exception occurred or not. It is typically used for cleanup actions, like closing files or releasing resources.

Example:

```python
try:
    file = open("test.txt", "r")
    data = file.read()
except FileNotFoundError:
    print("The file does not exist!")
finally:
    file.close()  # Ensures the file is always closed, whether an error occurred or not
```

## **5. Raising Exceptions**

You can also manually raise exceptions in your code using the `raise` keyword. This is useful when you want to enforce certain conditions.

Example:

```python
def check_age(age):
    if age < 18:
        raise ValueError("Age must be 18 or older")
    else:
        print("Age is valid")

try:
    check_age(16)
except ValueError as e:
    print(f"Error: {e}")
```

Output:

```
Error: Age must be 18 or older
```

## **6. Custom Exceptions**

In Python, you can create your own exceptions by subclassing the built-in `Exception` class.

Example:

```python
class CustomError(Exception):
    pass

try:
    raise CustomError("This is a custom error")
except CustomError as e:
    print(f"Custom Error: {e}")
```

Output:

```
Custom Error: This is a custom error
```

---

## **Why Use Error Handling?**

Error handling allows you to:

* Prevent your program from crashing unexpectedly.
* Provide clear error messages to users.
* Ensure that your program can recover from errors and continue running.

Good error handling can improve the user experience, making your code more robust and reliable.
